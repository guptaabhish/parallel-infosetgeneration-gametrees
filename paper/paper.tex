\documentclass[11pt]{article}
\usepackage{amsmath,amsfonts,latexsym,graphicx}
\usepackage{fullpage}
\usepackage{url,hyperref}
\usepackage{subfig}
\usepackage{tikz}
\usepackage{examplep}
\usepackage{moreverb}
\usepackage{listings}
\lstset{language=C,numbers=left,basicstyle=\footnotesize,numberstyle=\footnotesize}
\usetikzlibrary{arrows,decorations.pathmorphing,backgrounds,fit,shapes.geometric}
\usepgflibrary{shapes.geometric}
%\usepackage{ijcai09}


\setlength{\oddsidemargin}{0in}
\setlength{\topmargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{8.5in}

\newtheorem{fact}{Fact}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{theorem}[lemma]{Theorem}
\newtheorem{assumption}[lemma]{Assumption}
\newtheorem{definition}[lemma]{Definition}
\newtheorem{corollary}[lemma]{Corollary}
\newtheorem{prop}[lemma]{Proposition}
\newtheorem{claim}[lemma]{Claim}
\newtheorem{remark}[lemma]{Remark}
\newtheorem{prob}{Problem}
\newtheorem{conjecture}{Conjecture}


\newenvironment{mylisting}
{\begin{list}{}{\setlength{\leftmargin}{1em}}\item\scriptsize}
{\end{list}}

\newenvironment{mytinylisting}
{\begin{list}{}{\setlength{\leftmargin}{1em}}\item\scriptsize\texttt}
{\end{list}}
\newenvironment{proof}{\vspace{-0.15in}\noindent{\bf Proof:}}%
        {\hspace*{\fill}$\Box$\par}
\newenvironment{proofsketch}{\noindent{\bf Proof Sketch.}}%
        {\hspace*{\fill}$\Box$\par\vspace{4mm}}
\newenvironment{proofof}[1]{\smallskip\noindent{\bf Proof of #1.}}%
        {\hspace*{\fill}$\Box$\par}

\newcommand{\etal}{{\em et al.}\ }
\newcommand{\assign}{\leftarrow}
\newcommand{\eps}{\epsilon}

%\newtheorem{lemma}{Lemma}
%\newtheorem{theorem}[lemma]{Theorem}
\begin{document}

\title{Information Set Generation in Kriegspiel}
\author{Abhishek Gupta\qquad Mark Richards\qquad Osman Sarood\\University of Illinois at Urbana-Champaign\\CS598LVK:
Parallel Combinatorial Search} \maketitle

\begin{abstract}
Information Set Generation is the identification of the set of paths in an imperfect information game tree that are
consistent with a player's observations.  The ability to reason about the possible state of the world is crucial to the
performance of game playing agents.  In this work, we discuss the problem of information set generation in the context
of kriegspiel (partially observable chess).  We implement the algorithm on top of a general purpose combinatorial search
engine and discuss its performance under different load balancing strategies and with different grainsize parameters.
We discuss some variations in the search strategy and their effect on performance.  \end{abstract}

\section{Introduction}
In imperfect information games, players do not have access to full knowledge of the world. Examples of imperfect
information include hidden cards in Poker~\cite{billings02challenge} or Bridge~\cite{ginsberg96partition}, hidden tiles
in Scrabble~\cite{richards07opponent}, or hidden pieces in Stratego or Kriegspiel (partially observable
chess)~\cite{li94chess}. The game tree nodes that are indistinguishable to a player because they differ only in the
information that is hidden to the player by rule are called that player's {\em information set.}  The ability to
estimate the value of the possible states and to reason about the probability distribution over those states is crucial
to playing imperfect information games well. 

The term {\em belief state} is sometimes used interchangeably with information set to refer to a probability
distribution over possible worlds.  The latter term comes from the game theory community and is preferred here.  A node
in a game tree denotes not only the current state of the game, but also uniquely defines a path from the initial state
or root node.  Thus, a game tree node implicitly encodes not only the current state of the game, but also all the
history of all decisions made by all players up to that point in the game.  Knowing one's information set means knowing
all possible game histories.

For many games, solving the information set generation problem is trivial.  For example, in a poker game, it is easy to
see that the unseen cards held by a player's opponents may be any permutation of the cards not seen by that player
(i.e., hole cards and any revealed community cards).  After the betting rounds, it would not be reasonable to assume
that each of these permutations of unseen cards is equally probable, as betting decisions made by the players up to that
point would be affected by the quality of those players' cards.  But the set of {\em possible} hands for all of the
opponents is easy to conceive and enumerate.

In the game of kriegspiel, information set generation is non-trivial.  The player knows the opponent's position with
certainty when the game begins, but after the initial move there may be varying levels of uncertainty about the location
of the opponent's pieces.  Unlike poker, it is not possible to simply permute all of the opponent's possible pieces over
all of the squares not occupied by the player's own pieces.  A configuration of pieces for the opponent is only valid if
it can be reached by a legal sequence of moves.  In the general case, finding the nodes in an information set is a
combinatorial search problem.

Information set generation is not the same problem as solving a game
tree, although it is arguably a necessary subroutine for quality game play in imperfect information games. The standard
game tree problem is to find an equilibrium (i.e., minimax) strategy for the game. This can be done using alpha-beta
pruning for perfect information games or linear programming for imperfect information games. Information set generation,
by contrast, is the problem of finding sequences of moves in the game tree that are consistent with a player's
observations.

\section{Background}
In this section, we describe the game of kriegspiel, and the particular variation of it that we have implemented.

Kriegspiel was invented by Henry Michael Temple in 1899.  Historically, the game has required three parties: two
competing players and one referee.  Each player sits with a chessboard that is partitioned off so as not be seen by the
others.  One player controls the white pieces; the other controls the black pieces.  The referee keeps track of both
sets of pieces.  Each player has a full set of chess pieces.  He may position the opponent's pieces however he wishes on
his own board (if at all).  The players alternate moves as in a regular chess game, but instead of announcing their
moves out loud, they write the source and destination square of their desired play son a piece of paper and pass them to
the referee, so that the move is not heard by the other player. The referee, who knows the location of all pieces,
checks the legality of the move.  If the move is legal, the referee makes the move on his own board and announces that a
legal move has been made and that it is the other player's turn to move.  If the move is illegal because it is blocked
by an opponent's piece or would place or leave the active player in check, the referee announces, "No."  There is no
penalty for attempting an illegal move.  The player continues to attempt moves until one finally succeeds.  If a player
has no legal moves (because of stalemate or checkmate), the referee announces the game's result.  With the advent of
computers, it is convenient to play the game over a network, with a computer acting as the referee.

The referee makes other announcements besides declaring move illegal, and there are several variations of the game that
differ only in the nature of these announcements.  All declarations by the referee are heard by both players.  Thus, for
example, a player will hear and know if her opponent has attempted an illegal move, and will thus know that her
opponent's pieces are configured in such a way as to allow at least one attemptable move that blocked or would leave him
in check.  

The referee announces when a player is in check.  (And again, this announcement is heard by both players.)  There is
some variation in what additional information is supplied in this case.  In one popular variant, the referee declares
that the player is in check "by rank," "by file," "by diagonal," or "by knight."  In the case of a diagonal attack, the
referee may announce whether the checking piece is along the long or short diagonal (from the king's perspective).  It
is possible to be in check by two pieces at the same time, in which case the direction of both attacks would be
declared.  In our implementation, for simplicity, the referee declares only that the player is in check, without
specifying the nature of the attack.

In the case of the capture, the referee announces the location of the piece that was captured, so that both players can
remove the piece from the board.  In some variations, the referee also announces whether the captured piece was a pawn
or non-pawn.  In our implementation, information about the captured piece is not explicitly provided to the player who
makes the capture.

Because there is no penalty for making illegal moves, it is often to a player's advantage to attempt to make moves which
are likely to be illegal, as hearing such declarations from the referee can provide important information to a player
about the location of the opponent's pieces.  In particular, since a diagonal move by a pawn is legal only the case
where such a move would capture an opponent's piece, it could potentially be profitable to attempt all or many pawn
captures on every turn.  In order to speed the game up, popular variants of the game require the referee to make some
kind of declaration at the beginning of a player's turn with respect to the pawn captures that are available.  This may
be as simple as declaring "Try" to indicate that at least one pawn capture is possible.  In our implementation, the
referee declares all possible pawn captures.

In the case of a pawn promotion, the player making the pawn advancement would secretly notify the referee as to which
piece (queen, rook, bishop, or knight) he would like.  To reduce the number of bits needed to specify a move, our
implementation assumes and allows only promotion to queen. 

In general, any move that is legal in a regular chess match may be at least attempted by a player in kriegspiel.  And
any kriegspiel move that is ultimately allowed by the referee would also be a legal move in chess.    

We assume that a player may not attempt the same illegal move more than once per turn.  This means that if a player
hears multiple declarations from the referee that the opponent has attempted an illegal move, the player may assume that
the opponent has at least that many possibilities available to him.

\subsubsection{Special Moves}
Our implementation supports the capability for pawns to move two spaces on their first turn.  However, we did not
implement support for castling or {\em en passant} pawn capture.  (These moves require maintaining additional bits of
information at each state that keep track of whether pieces have moved and/or whether pieces moved on the previous
turn.) 

\subsection{Example}
\begin{figure}
%\includegraphics[width=0.2\textwidth]{images/1W.png}
\begin{minipage}{\textwidth}
\centering
\subfloat[1. d4]{\label{fig:1W}\includegraphics[width=0.2\textwidth]{images/1W.png}}
\qquad
\subfloat[1. ... a5]{\label{fig:1B}\includegraphics[width=0.2\textwidth]{images/1B.png}}
\qquad
\subfloat[2. Bg5]{\label{fig:2W}\includegraphics[width=0.2\textwidth]{images/2W.png}}
\qquad
\subfloat[2. ... b6]{\label{fig:2B}\includegraphics[width=0.2\textwidth]{images/2B.png}}
\end{minipage}
\begin{minipage}{\textwidth}
\centering
\subfloat[3. Nc3]{\label{fig:3W}\includegraphics[width=0.2\textwidth]{images/3W.png}}
\qquad
\subfloat[3. ... c5]{\label{fig:3B}\includegraphics[width=0.2\textwidth]{images/3B.png}}
\qquad
\subfloat[4. d5]{\label{fig:4W}\includegraphics[width=0.2\textwidth]{images/4W.png}}
\qquad
\subfloat[4. ... Na6]{\label{fig:4B}\includegraphics[width=0.2\textwidth]{images/4B.png}}
\end{minipage}
\begin{minipage}{\textwidth}
\centering
\subfloat[5. d6!]{\label{fig:5W}\includegraphics[width=0.2\textwidth]{images/5W.png}}
\qquad
\subfloat[5. ... f6!]{\label{fig:5B}\includegraphics[width=0.2\textwidth]{images/5B.png}}
\qquad
\subfloat[6. e4]{\label{fig:6W}\includegraphics[width=0.2\textwidth]{images/6W.png}}
\qquad
\subfloat[6. ... fg]{\label{fig:6B}\includegraphics[width=0.2\textwidth]{images/6B.png}}
\end{minipage}
\begin{minipage}{\textwidth}
\centering
\subfloat[7. Bc4]{\label{fig:7W}\includegraphics[width=0.2\textwidth]{images/7W.png}}
\qquad
\subfloat[7. ... ed]{\label{fig:7B}\includegraphics[width=0.2\textwidth]{images/7B.png}}
\qquad
\subfloat[8 Qd5!]{\label{fig:8W}\includegraphics[width=0.2\textwidth]{images/8W.png}}
\qquad
\subfloat[8 ... Qc7?]{\label{fig:8B}\includegraphics[width=0.2\textwidth]{images/8B.png}}
\end{minipage}
\begin{minipage}{\textwidth}
\centering
\subfloat[9 Qf7+]{\label{fig:9W}\includegraphics[width=0.2\textwidth]{images/9W.png}}
\qquad
\subfloat[9 ... d8]{\label{fig:9B}\includegraphics[width=0.2\textwidth]{images/9B.png}}
\qquad
\subfloat[10 Qxf8++]{\label{fig:10W}\includegraphics[width=0.2\textwidth]{images/8W.png}}
\end{minipage}
\caption{Sequence of moves}
\label{sequence}
\end{figure}

\begin{figure}
\begin{verbatim}
1. d4 {(:)}
   a5 {(:)}
2. Bg5 {(:)}
   b6 {(:)}
3. Nc3 {(:Bd8)}
   c5 {(:)}
4. d5 {(:Bd8;Tc5)}
   Na6 {(:)}
5. d6 {(:)}
   f6 {(:Td6)}
6. e4 {(:)}
   fxg5 {(Xg5:Td6;Tg5)}
7. Bc4 {(:)}
   exd6 {(Xd6:Td6)}
8. Qd5 {(:)}
   Qc7 {(:)}
9. Qf7+ {(:)} 
   d8 {:g6,f7,e7}
10. Qxf8++ {(1-0:)}
\end{verbatim}
\caption{Listing of a kriegspiel game resulting in checkmate by white after 10 moves.}
\label{listing}
\end{figure}

The concept of information sets is perhaps best explained through an example.  Figures~\ref{listing} and~\ref{sequence}
show a full listing and the associated pictorial simulation of an actual kriegspiel game from ~\cite{li94chess}.  We
have adapted the notation used by Wolfe for Berkeley Kriegspiel.  The moves are numbered in pairs: a move by white on
one line followed by black's move on the next line.  The actual move is shown first followed by a list of referee
announcements.  Captures announcements are prefixed with an X and give the location of the captured piece.  Similarly,
pawn tries announcements are prefixed with T.  Attempted moves that were ultimately declared illegal are shown in a list
following the ':'.  For example at move 9, (Figure~\ref{fig:9W}--\ref{fig:9B}), black attempts to block a potential
threat along the diagonal by moving a pawn to f6, then attempts to escape or capture a threat at f7.  When both of these
attempts fail, black can infer that his king is being threatened by a protected bishop or queen at f7.  The attempt to
move to e7 is black's way of finding out whether the threatening piece is a queen or bishop.  When this move fails,
black knows it is white's queen and ultimately retreats to d8.  Note that the failed moves by white on turns 3 and 4 are
a result of being blocked by the pawn at e2.


Note that the listing in Figure~\ref{listing} corresponds to the referee's view of the game and would be useful for
post-game analysis or commentary.  During the game, players would not have access to the full information.  The
transcript from white's perspective is shown in Figure~\ref{filteredlisting}.  Note that black's actual moves have been
replaced with ``??'' and lists of black's illegal moves have been replaced with the {\em number} of illegal attempted
moves.  For example, on move 9, black attempted three illegal moves.
\begin{figure}
\begin{verbatim}
1. d4 {(:)}
   ?? {(:0)}
2. Bg5 {(:)}
   ?? {(:0)}
3. Nc3 {(:Bd8)}
   ??  {(:0)}
4. d5 {(:Bd8;Tc5)}
   ??  {(:0)}
5. d6 {(:)}
   ?? {(:0,Td6)}
6. e4 {(:)}
   fxg5 {(Xg5:Td6;Tg5)}
7. Bc4 {(:)}
   ?? {(Xd6:Td6)}
8. Qd5 {(:)}
   ?? {(:0)}
9. Qf7+ {(:)} 
   ?? {:0}
10. Qxf8++ {(1-0:)}
\end{verbatim}
\caption{Listing of a kriegspiel game resulting in checkmate by white after 10 moves.}
\label{filteredlisting}
\end{figure}

The listing of a sequence of moves from the perspective of one player lists all of that player's moves exactly and
includes the declarations from the referee.  We refer to such a list as a player's observations.  Given a list of
observations for a sequence of moves, an information set is the set of all possible {\em sequences of moves for both
players}, that are consistent with those observations.  Figure~\ref{abbrevoutput} shows the information set for black
after both player's have made five moves.  From this list of possibilities, black can infer that white must have a
bishop at g5 and a pawn at d6.  There are 25 possible sequences of moves that are consistent with black's observations
up to that point. Table~\ref{bothtimes} shows the size of the information sets for each player for each move in the game
and the amount of time to find the full set on a single processor.  Appendix B shows the full output of the program for
the same point in the game (five moves for each player) and illustrates all of the possible positions in the belief
state.

\begin{figure}
\begin{mytinylisting}
1. Pa2:a4 Pa7:a5 2. Pd2:d4 Pb7:b6 3. Bc1:g5 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 \\
1. Pd2:d3 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Pd3:d4 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 \\
1. Pd2:d4 Pa7:a5 2. Pa2:a4 Pb7:b6 3. Bc1:g5 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 \\
1. Pd2:d4 Pa7:a5 2. Bc1:f4 Pb7:b6 3. Bf4:g5 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 \\
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Pa2:a3 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 \\
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Pa2:a4 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 \\
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Pb2:b3 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 \\
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Pc2:c3 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 \\
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Pe2:e3 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 \\
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Pe2:e4 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 \\
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Pf2:f3 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 \\
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Pf2:f4 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 \\
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Pg2:g3 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 \\
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Pg2:g4 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 \\
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Ph2:h3 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 \\
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Ph2:h4 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 \\
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Nb1:a3 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 \\
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Nb1:c3 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 \\
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Nb1:d2 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 \\
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Qd1:d2 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 \\
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Qd1:d3 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 \\
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Qd1:c1 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 \\
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Ke1:d2 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 \\
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Ng1:f3 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 \\
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Ng1:h3 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 \\
\end{mytinylisting}
\caption{Abbreviated output from example game.  Generating information sets for black after five turns by each player.
From this, black can infer that there is definitely a white bishop at g5 and a white pawn at d6.}
\label{abbrevoutput}
\end{figure}

\begin{table}
\centering
\begin{tabular}{rrrrr}
 & \multicolumn{2}{c}{\bf White} & \multicolumn{2}{c}{\bf Black} \\
{\bf Ply} & {\bf Size} & {\bf Time} & {\bf Size} & {\bf Time} \\
1 & 18 & 0.000 & 20 & .000 \\
2 & 18 & 0.000 & 19 & .000 \\
3 & 18 & 0.000 & 404 & .008\\
4 & 279 & 0.008 & 401 & .024\\
5 & 242 & 0.028 & 1472 & .044\\
6 & 216 & 0.052 & 155 & .096\\
7 & 176 & 0.064 & 293 & .116\\
8 & 3406 & 0.092 & 158 & .128\\
9 & 2191 & 0.288 & 118 & .148\\
10 & 1423 & 0.508 & 25 & .152\\
11 & 1363 & 0.596 & 798 & .164\\
12 & 1416 & 0.744 & 518 & .192\\
13 & 1416 & 0.836 & 13564 & .304\\
14 & 3440 & 0.97 & 12394 & .776\\
15 & 3428 & 1.25 & 343652 & 3.75\\
16 & 50521 & 1.82 & 320704 & 17.3\\
17 & 43192 & 5.91 & 490162 & 99.9\\
18 & 26128 & 7.94 & 3792 & 119\\
19 & 19061 & 9.92 & 14836 & 121\\
\end{tabular}
\caption{Solution counts and running times for a sample kriegspiel game}
\label{bothtimes}
\end{table}

%Table~\ref{sampletimes}
%\begin{table}
%\begin{tabular}{ccc}
%1 & 20 & .000\\
%2 & 19 & .000\\
%3 & 404 & .008\\
%4 & 401 & .024\\
%5 & 1472 & .044\\
%6 & 155 & .096\\
%7 & 293 & .116\\
%8 & 158 & .128\\
%9 & 118 & .148\\
%10 & 25 & .152\\
%11 & 798 & .164\\
%12 & 518 & .192\\
%13 & 13564 & .304\\
%14 & 12394 & .776\\
%15 & 343652 & 3.75\\
%16 & 320704 & 17.3\\
%17 & 490162 & 99.9\\
%18 & 3792 & 119\\
%19 & 14836 & 121 \\
%\end{tabular}
%\caption{Solution counts and running times for a sample kriegspiel game}
%\label{blacktimes}
%\end{table}

   
\section{The Information Set Generation Algorithm}
\begin{figure}
%\begin{listing}
\begin{lstlisting}
void generateInformationSet(uint16_t* trueState, uint16_t* possState, bool whiteMove, 
	uint16_t* possHistory, uint16_t** levels, int depth)
{
  if (!samePawnTries(trueState, possState, whiteMove)) return;  
  if (!sameCheckStatus(trueState, possState, whiteMove)) return; 
  if (depth == maxdepth) { // Then we have found a solution
	nSolutions++; return; // Report solution
  }
  uint16_t newPossState[16]; 
  int nMoves = 0;
  generateAttemptableMoves(possState, whiteMove, levels[depth], nMoves,false);
  checkForCheck(possState, whiteMove, levels[depth], nMoves); // prunes if not equal
  assert (nMoves < NMOVES); // 

  if (whitePerspective == whiteMove) { // move from perspective plyaer 
    SetMove& failures = failedMoves[depth];
    for (SetMove::const_iterator itr = failures.begin(); itr != failures.end(); ++itr) {
      uint16_t move = *itr ;
      if (!foundMatchingMove(move,levels[depth],nMoves)) {
        return; // Prune: one of my own failed moves is not attemptable in this state
      }
    }
    // We know exactly what the actual move was; make it
    uint16_t& actualMove = moveHistory[depth];
    if (!foundMatchingMove(actualMove,levels[depth],nMoves)) {
      return; // Prune (because the move that we know we made at this depth is not legal)
    }
    // Otherwise, recurse 
    applyMove(possState,newPossState,actualMove);
    possHistory[depth] = actualMove;
    generateInformationSet(newTrueState, newPossState, !whiteMove, 
      possHistory, levels, depth+1);
  } else { 
    // We are at a level in the search tree where 
    // we are considering the possible moves for the opponent.
    // We know the number of attempted illegal moves, but not which ones

    // Must be enough attemptable moves in the state to match the number of failed attempts
    unsigned nIllegalMoves = countIllegalMoves(levels[depth], nMoves);
    if (nIllegalMoves < failedMoves[depth].size()) {
	return; // Prune if not enough attemptable moves
    }
    // Now we want to try each possible move that is legally executable (not just attemptable) 
    for (int i = 0; i < nMoves; i++) {
      uint16_t& move = levels[depth][i];
      if (isLegal(move)) { // Obviously, we can only execute the moves that are actually legal from this state
        applyMove(possState,newPossState,move);
        possHistory[depth] = move;
        generateInformationSet(newTrueState, newPossState, !whiteMove, 
          possHistory, levels, depth+1);
      }
    }
  }
}
\end{lstlisting}
\caption{The heart of the information set generation algorithm.}
\label{codelisting}
\end{figure}

Figure~\ref{codelisting}

\section{Performance Results}


Table~\ref{speedups} shows the performance results for our algorithm on a randomly selected problem instance in which
the size of the information set was about 4.5 million.  (This instance is not necessarily representative of all games or
states of the game, but it was not cherry-picked in any way.)

\begin{table}
\centering
\begin{tabular}{rrr}
{\bf Procs}	&	{\bf Time (s)} 	&	{\bf Speedup}\\
1	&	1524	&	1\\
2	&	812	&	1.88\\
4	&	407	&	3.74\\
8	&	208	&	7.32\\
16	&	102	&	14.8\\
32	&	53.2	&	28.7\\
64	&	28.0	&	54.5\\
128	&	14.9	&	102\\
256	&	7.70	&	197\\
512	&	4.59	&	331\\
1024	&	2.64	&	576\\
\end{tabular}
\caption{Speedups for a randomly selected problem instance on 1--1024 processors.  The size of the information set in
this instance is 4,495,121.}
\label{speedups}
\end{table}

Figure~\ref{3schemes}
\begin{figure}
\centering
\includegraphics[width=0.7\textwidth]{plots/3schemes.pdf}
\caption{3schemes}
\label{3schemes}
\end{figure}
 
Figure~\ref{3depths}
\begin{figure}
\begin{minipage}{0.5\linewidth}
\centering
\includegraphics[width=\textwidth]{plots/3depths.pdf}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\centering
\includegraphics[width=\textwidth]{plots/3depthsnolog.pdf}
\end{minipage}
\caption{3depths}
\label{3depths}
\end{figure}
 
Figure~\ref{dep8}
\begin{figure}
\centering
\includegraphics[width=0.7\textwidth]{plots/dep8.pdf}
\caption{dep8}
\label{dep8}
\end{figure}
 
Figure~\ref{dep10}
\begin{figure}
\centering
\includegraphics[width=0.7\textwidth]{plots/dep10.pdf}
\caption{dep10}
\label{dep10}
\end{figure}
 
Figure~\ref{dep12}
\begin{figure}
\centering
\includegraphics[width=0.7\textwidth]{plots/dep12.pdf}
\caption{dep12}
\label{dep12}
\end{figure}
 

\section{Related Work}
An overview of the theory of imperfect information games and other basic topics in game theory can be found in
~\cite{kuhn03lectures} and~\cite{kuhn97classics}.  A technical explanation of the concept of information sets can be
found in~\cite{gilpin07algorithms}.  Algorithms for ``solving'' imperfect information games---in the sense of finding a
Nash equilibrium---can be found in~\cite{koller94fast} and~\cite{koller97representations}.  Koller \etal, showed that an
equilibrium can be found in time that is polynomial in the size of the game tree.  And in fact, they found that it took
about as much time to generate the full game tree as it did to actually solve it.  Unfortunately, this is feasible only
for small games.  In larger games where theoretically optimal strategies cannot be computed efficiently, computer
systems tend to utilize the concept of infomration sets in some form or another.  A common strategy is to estimate the
value of a move by averaging the estimated value of the associated descendant for each node in the current information
set (or a random sample from the set).  While this sort of ``averaging over clairvoyance'' {\em can} lead to very poor
decisions, it is nevertheless a reasonable strategy in some games (e.g., Scrabble~\cite{sheppard02world}).

In this work, we have argued for an information set generation approach to kriegspiel, but other authors have approached
the problem differently.  Parker \etal, consider the problem of sampling from belief states in a variety of large
game trees, including kriegspiel~\cite{parker05game}.  They show that some performance gains can be achieved by only
approximate sampling from the belief state.  Instead of generating the full information set, or even sampling from it,
they sample from possible positions for the current state (i.e., sampling from the belief state) by matching only the
most recent observations.  This motivation for this approach seems to be that it would not be feasible to sample from
the full information set, because of the computational expense involved.  And indeed, our experiments bear this out-- it
can indeed be expensive to produce the full information set.  For the experiments shown in Table XX, generating the full
information set took over 25 minutes on a single processor.  However, by utilizing the Charm++ search engine on a
parallel machine (1024 processors), we were able to generate the full set in just 2.9 seconds.  (Note that this set had
more than 4 million members.)  Our results suggest that the problem is highly scalable and our approach might therefore
be preferred.

Li gives an overview of kriegspiel and discusses strategy from the perspective of human players~\cite{li94chess}.  He
walks through the analysis of several actual games between two human players and discusses the inferences that each
player can and should make at each position.  As in chess, human players are able to reason about the game at an
abstract level; they tend to focus on a small number of critical possibilities and to emphasize the most important
pieces and squares in each position.  Computer agents, lacking such sophistication, nevertheless have some advantages
when it comes to brute force search strategies. Programs such Deep Blue have shown that a brute force approach to game
tree search can be effective, even against humans with vastly superior abstract reasoning capabilities, provided that
significant computational resources are available and wisely used~\cite{campbell02deep}.

Russell and Wolfe have performed some analyses on kriegspiel positions for which it possible to prove that one player
has a forced win (that is, regardless of the configuration of the opponent's unseen pieces, the player has a sequence of
moves that is guaranteed to produce a checkmate)~\cite{russell05efficient, wolfe07exploiting}.  The authors assume
knowledge of the player's belief state.  They claim that under certain "aggressive" styles of play, it is uncommon for
information sets to exceed 10,000 nodes in size.  They throw out (i.e., do not analyze) any positions that exceed this
threshold.  

In our experiments, we have found positions in which the size of the information set is many tens of millions.  Our goal
is to develop strategies that are amenable to use in this more general setting.   In other words, rather than being able
to analyze positions only at the beginning or end of the game (when the size of the information set tends to be
smaller), we want to be able to develop a strategy that can be used in the middle of the game as well.  game). 

Nance \etal, approach the game from the perspective of {\em logical filtering.}~\cite{nance06reasoning}  The goal of
logical filtering is to maintain a compact logical representation of an agent's belief state.  Recall that a belief
state is a probability distribution over the possible current states of the world.  A belief state for kriegspiel might
take the form of $(at(whitepawn,a2) \wedge at whitepawn(b2) \ldots \wedge at(whiterook,h1)) \vee (at(whitepawn,a3)
\wedge \ldots \wedge at(whiterook,h1)) \ldots$  For even moderately sizes information sets, such
representations can become unwieldy in terms of storage and the cost of updating.  Furthermore, reasoning with such
representations often requires the use of some theorem-proving mechanism to run logical queries, such
as $at(blackking,a3?)$. Nance et al. develop some strategies to maintain compact representations under
sequences of actions and observations.  They give a theoretical analysis of the kinds of problems that can be treated in
this way.  Unfortunately, kriegspiel in its full complexity is beyond the scope of their algorithm.  In order to reason
about the belief states in the game, they must assume knowledge of the particular kind of piece that move in each turn.

The information set generation approach that we have presented is certainly also computationally expensive.  And
representing a full information set (e.g., as a list of sequences of moves that encode a path from the start state to
the current node) would be similarly expensive in terms of storage space.  However, we have shown that our algorithm is
also highly scalable.  Furthermore, contrary to the approach in~\cite{nance06reasoning}, our approach is readily
adaptable to sampling algorithms.  Given a sample size that matches available memory, any single sequence of moves is
readily extractable without the computational expense of a theorem prover or SAT solver.

\section{Future Work}

First and foremost, it would be interesting to see how our information set generation algorithm would perform as a
subroutine to an actual kriegspiel playing program.  The utility of generating an information set is ultimately
determined by how well that information improves a player's decision-making capabilities.  We noted earlier that a
common use of information sets is to estimate the value of a move by averaging the estimated value of the associated
descendant for each node in the current information set (or a random sample from the set).  This kind of strategy can be
applied naively using a belief state sampling algorithm (i.e., an algorithm that samples from the distribution of
possible worlds in the current state without respect to the overall history mof moves).  However, it has been shown that
significant improvement in play can be achieved by estimating the value of future moves from the perspective of the
opponent, based on the knowledge that the opponent would have had at prior positions in the move
hisotry~\cite{richards07opponent}.  Such a strategy would require the use of an information set generation algorithm of the
kind that we have described here.\footnote{This work is underway.}

Ideally, we would run our algorithm on some deeper instances from real kriegspiel games.  We are not aware of a
repository of such games.  Unfortunately, notation for kriegspiel is not standardized and there are several minor
variations in rules (i.e., with respect to the nature of referee announcements) that are unlikely to significantly to
impact the computability and scalability results but which nevertheless make it difficult to write an input reader that
converts the transcript of a game into a sequence of moves readable by our algorithm.  An alternative would be to play
some games ourselves.  Currently, the manual encoding of games is not difficult but is tedious.  Still, it would be nice
to have some games that go on for 40 or 50 moves and have positions where the information sets are on the order of a few
hundred thousand or a few million in size.

The information set generation algorithm that we have implemented here is one the most straightforward one and is
alluded to in~\cite{parker05game} and~\cite{russell05efficient}.  It is analogous to the ``expand-at-the-tip'' strategy
for the Hamiltonian Circuit problem.  An alternative information set generation algorithm is described in
~\cite{richards09information} and could potentially improve the search efficiency greatly by exploiting variable
ordering.  This would be analgous to the disconnected edge-pairs\footnote{what we referred to as ``algorithm 2'' in
class} heuristic for the Hamiltonian Circuit problem.  Rather than search from the root node going forward, this
algorithm would seek opportunities for pruning based on the propagation of logical consequences from each move both
forward and backward in time.  This, incidentally, is more consistent with the way human players would analyze the game.
For example, if a player's proposed bishop move is rejected and the bishop is sufficiently removed from its own king,
then the player may infer that one of his opponent's pieces is along that rejected path.  At least one of those spaces
must have been the destination of a prior move by the opponent.  If a recent move by that bishop crossed the same path,
then that would be hard evidence that those squares were empty at the time.  And therefore, the arrival of the
opponent's piece must have been between the previous (successful) bishop move and the current (unsuccessful) bishop
move.  To implement this algorithm, we envision the use of planning graph type data structures ~\cite{GRAPHPLAN}.
Planning graphs have a sequence of alternating levels of state constraints and action constraints.  State constraints
would be of the form $at(bishop,d4) \vee at(bishop,e6)$ or $!occupied(e4)$.  Action constraints would be of the form
$move(knight,a4,c5) \vee move(knight,e6)$.  At a minimum, each level would require a data structure with a bit for each
possible action/state.  Propagating the constraints would require much of the same machinery used in STRIPS-like
planning algorithms~\cite{STRIPS}, and one of the many knobs that would need to be tuned would be the depth of the
propagation for each constraint.  (Should the consequences of a known action or non-action be propagated one move into
the future and one move into the past?  More?  Less?)  Additionally, there would be a significant and interesting
tradeoff in the effectiveness of pruning and the and the size of the data structures that would have to be encoded in
each chare.  The best algorithm might be a hybrid strategy that does forward propagation from the root at the parallel
level and constraint propagation at the sequential level.\footnote{This work is also in progress.}

There are certainly several places where the efficiency of the details of each node expansion could be improved.  Many
of these would reduce the overall running time but would not necessarily be interesting from the standpoint of
evaluating the efficiency and isoefficiency of parallelization.  For example, in checking to see if a position leaves a
player in check, we currently utilize existing helper functions that generate possible moves for the opponent.  It would
be possible to write a more specialized function that focuses only on the position of the king in question and looks
only at the squares along its rank, file, diagonals, and knight-edges for threats.  There are also some memory
allocation issues that could be improved. 


\section{Appendix A}
Figure~\ref{fulltree} shows the full game tree for a simple variant of poker known as Kuhn poker.  There are three
cards: a king, a queen, and a jack.  The dealer deals one card to each of two players.  Each player antes one unit, and
there is one simple round of betting, in which the size of the pot may be doubled.  Left branches denote check/fold;
right branches denote bet/call.  For this zero-sum game, terminal nodes are labeled with payoffs to player 1, whose
decision points are shown in triangles.  Connections between nodes in the same information set are shown with dotted
lines.

\begin{figure}
\scalebox{.72}{
\begin{tikzpicture}
  [chance/.style={circle,draw=blue!50,fill=blue!20,thick,minimum size = 10mm},
   terminal/.style={rectangle,draw=black!50,fill=black!20,thick, minimum size = 7mm},
   maxer/.style={shape=regular polygon, regular polygon sides=3,draw=red!50,fill=red!30,thick,minimum size = 10mm,inner sep = 0pt},
   miner/.style={shape=diamond,draw=green!50,fill=green!30,thick,minimum size = 10mm, inner sep = 0pt},
   edge from parent/.style={red,thick,draw}, 
   parent anchor=south,child anchor=north,
   level 1/.style={sibling distance=4cm,level distance=1.4cm,
       		growth parent anchor=south},
   level 2/.style={sibling distance=2cm},
   level 3/.style={sibling distance=1cm},
   level 4/.style={sibling distance=1.0cm}]
		\node  [chance] {}
		    child {node (M1) [maxer] {\scalebox{.75}{K}}
			child {node (M11) [miner] {\scalebox{.75}{Q-}}
				child {node (M111) [terminal] {1}}
				child {node (M112) [maxer] {\scalebox{.75}{K+}}
					child {node (M1121) [terminal] {-1}}
					child {node (M1122) [terminal] {2}}}
			}
			child {node (M12) [miner] {\scalebox{.75}{Q+}}
				child {node (M121) [terminal] {1}}
				child {node (M122) [terminal] {2}}
			}
		    }
		    child {node (M2) [maxer] {\scalebox{.75}{J}}
			child {node (M21) [miner] {\scalebox{.75}{Q-}}
				child {node (M211) [terminal] {-1}}
				child {node (M212) [maxer] {\scalebox{.75}{J+}}
					child {node (M2121) [terminal] {-1}}
					child {node (M2122) [terminal] {-2}}}
			}
			child {node (M22) [miner] {\scalebox{.75}{Q+}}
				child {node (M221) [terminal] {1}}
				child {node (M222) [terminal] {-2}}
			}
		    }
		    child {node (M3) [maxer] {\scalebox{.75}{K}}
			child {node (M31) [miner] {\scalebox{.75}{J-}}
				child {node (M311) [terminal] {1}}
				child {node (M312) [maxer] {\scalebox{.75}{K+}}
					child {node (M3121) [terminal] {-1}}
					child {node (M3122) [terminal] {2}}}
			}
			child {node (M32) [miner] {\scalebox{.75}{J+}}
				child {node (M321) [terminal] {1}}
				child {node (M322) [terminal] {2}}
			}
		    }
		    child {node (M4) [maxer] {\scalebox{.75}{Q}}
			child {node (M41) [miner] {\scalebox{.75}{J-}}
				child {node (M411) [terminal] {1}}
				child {node (M412) [maxer] {\scalebox{.75}{Q+}}
					child {node (M4121) [terminal] {-1}}
					child {node (M4122) [terminal] {2}}}
			}
			child {node (M42) [miner] {\scalebox{.75}{J+}}
				child {node (M421) [terminal] {1}}
				child {node (M422) [terminal] {2}}
			}
		    }
		    child {node (M5) [maxer] {\scalebox{.75}{J}}
			child {node (M51) [miner] {\scalebox{.75}{K-}}
				child {node (M511) [terminal] {-1}}
				child {node (M512) [maxer] {\scalebox{.75}{J+}}
					child {node (M5121) [terminal] {-1}}
					child {node (M5122) [terminal] {-2}}}
			}
			child {node (M52) [miner] {\scalebox{.75}{K+}}
				child {node (M521) [terminal] {1}}
				child {node (M522) [terminal] {-2}}
			}
		    }
		    child {node (M6) [maxer] {\scalebox{.75}{Q}}
			child {node (M61) [miner] {\scalebox{.75}{K-}}
				child {node (M611) [terminal] {-1}}
				child {node (M612) [maxer] {\scalebox{.75}{Q+}}
					child {node (M6121) [terminal] {-1}}
					child {node (M6122) [terminal] {-2}}}
			}
			child {node (M62) [miner] {\scalebox{.75}{K+}}
				child {node (M621) [terminal] {1}}
				child {node (M622) [terminal] {-2}}
			}
		    };
		\draw  (M1.north) to [dashed,black,out=15,in=165] (M3.north);
		\draw  (M2.north) to [dashed,black,out=15,in=165] (M5.north);
		\draw  (M4.north) to [dashed,black,out=15,in=165] (M6.north);
		\draw  (M112.north) to [dashed,black,out=15,in=165] (M312.north);
		\draw  (M212.north) to [dashed,black,out=15,in=165] (M512.north);
		\draw  (M412.north) to [dashed,black,out=15,in=165] (M612.north);
		\draw  (M11.north) to [dashed,black,out=15,in=165] (M21.north);
		\draw  (M12.north) to [dashed,black,out=15,in=165] (M22.north);
		\draw  (M31.north) to [dashed,black,out=15,in=165] (M41.north);
		\draw  (M32.north) to [dashed,black,out=15,in=165] (M42.north);
		\draw  (M51.north) to [dashed,black,out=15,in=165] (M61.north);
		\draw  (M52.north) to [dashed,black,out=15,in=165] (M62.north);
\end{tikzpicture}
} %scalebox
\caption{}
\label{fulltree}
\end{figure}




%\nocite{*}
%\nocite{richards09information}
%\nocite{russell05efficient}
%\nocite{kuhn03lectures}
%\nocite{kuhn97classics}
%\nocite{parker05sampling}
%\nocite{nance06reasoning}
%\nocite{li94chess}

%\begin{thebibliography}{99}
%\end{thebibliography}


%\begin{figure}

\section{Appendix B}
\begin{verbatim}
1. Pa2:a4 Pa7:a5 2. Pd2:d4 Pb7:b6 3. Bc1:g5 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 

**********************************************
R - B Q K B N R 
- - - P P - P P 
N P - p - P - - 
P - P - - - b - 
p - - - - - - - 
- - - - - - - - 
- p p - p p p p 
r n - q k b n r 
**********************************************
1. Pd2:d3 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Pd3:d4 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 

**********************************************
R - B Q K B N R 
- - - P P - P P 
N P - p - P - - 
P - P - - - b - 
- - - - - - - - 
- - - - - - - - 
p p p - p p p p 
r n - q k b n r 
**********************************************
1. Pd2:d4 Pa7:a5 2. Pa2:a4 Pb7:b6 3. Bc1:g5 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 

**********************************************
R - B Q K B N R 
- - - P P - P P 
N P - p - P - - 
P - P - - - b - 
p - - - - - - - 
- - - - - - - - 
- p p - p p p p 
r n - q k b n r 
**********************************************
1. Pd2:d4 Pa7:a5 2. Bc1:f4 Pb7:b6 3. Bf4:g5 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 

**********************************************
R - B Q K B N R 
- - - P P - P P 
N P - p - P - - 
P - P - - - b - 
- - - - - - - - 
- - - - - - - - 
p p p - p p p p 
r n - q k b n r 
**********************************************
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Pa2:a3 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 

**********************************************
R - B Q K B N R 
- - - P P - P P 
N P - p - P - - 
P - P - - - b - 
- - - - - - - - 
p - - - - - - - 
- p p - p p p p 
r n - q k b n r 
**********************************************
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Pa2:a4 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 

**********************************************
R - B Q K B N R 
- - - P P - P P 
N P - p - P - - 
P - P - - - b - 
p - - - - - - - 
- - - - - - - - 
- p p - p p p p 
r n - q k b n r 
**********************************************
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Pb2:b3 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 

**********************************************
R - B Q K B N R 
- - - P P - P P 
N P - p - P - - 
P - P - - - b - 
- - - - - - - - 
- p - - - - - - 
p - p - p p p p 
r n - q k b n r 
**********************************************
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Pc2:c3 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 

**********************************************
R - B Q K B N R 
- - - P P - P P 
N P - p - P - - 
P - P - - - b - 
- - - - - - - - 
- - p - - - - - 
p p - - p p p p 
r n - q k b n r 
**********************************************
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Pe2:e3 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 

**********************************************
R - B Q K B N R 
- - - P P - P P 
N P - p - P - - 
P - P - - - b - 
- - - - - - - - 
- - - - p - - - 
p p p - - p p p 
r n - q k b n r 
**********************************************
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Pe2:e4 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 

**********************************************
R - B Q K B N R 
- - - P P - P P 
N P - p - P - - 
P - P - - - b - 
- - - - p - - - 
- - - - - - - - 
p p p - - p p p 
r n - q k b n r 
**********************************************
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Pf2:f3 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 

**********************************************
R - B Q K B N R 
- - - P P - P P 
N P - p - P - - 
P - P - - - b - 
- - - - - - - - 
- - - - - p - - 
p p p - p - p p 
r n - q k b n r 
**********************************************
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Pf2:f4 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 

**********************************************
R - B Q K B N R 
- - - P P - P P 
N P - p - P - - 
P - P - - - b - 
- - - - - p - - 
- - - - - - - - 
p p p - p - p p 
r n - q k b n r 
**********************************************
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Pg2:g3 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 

**********************************************
R - B Q K B N R 
- - - P P - P P 
N P - p - P - - 
P - P - - - b - 
- - - - - - - - 
- - - - - - p - 
p p p - p p - p 
r n - q k b n r 
**********************************************
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Pg2:g4 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 

**********************************************
R - B Q K B N R 
- - - P P - P P 
N P - p - P - - 
P - P - - - b - 
- - - - - - p - 
- - - - - - - - 
p p p - p p - p 
r n - q k b n r 
**********************************************
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Ph2:h3 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 

**********************************************
R - B Q K B N R 
- - - P P - P P 
N P - p - P - - 
P - P - - - b - 
- - - - - - - - 
- - - - - - - p 
p p p - p p p - 
r n - q k b n r 
**********************************************
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Ph2:h4 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 

**********************************************
R - B Q K B N R 
- - - P P - P P 
N P - p - P - - 
P - P - - - b - 
- - - - - - - p 
- - - - - - - - 
p p p - p p p - 
r n - q k b n r 
**********************************************
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Nb1:a3 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 

**********************************************
R - B Q K B N R 
- - - P P - P P 
N P - p - P - - 
P - P - - - b - 
- - - - - - - - 
n - - - - - - - 
p p p - p p p p 
r - - q k b n r 
**********************************************
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Nb1:c3 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 

**********************************************
R - B Q K B N R 
- - - P P - P P 
N P - p - P - - 
P - P - - - b - 
- - - - - - - - 
- - n - - - - - 
p p p - p p p p 
r - - q k b n r 
**********************************************
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Nb1:d2 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 

**********************************************
R - B Q K B N R 
- - - P P - P P 
N P - p - P - - 
P - P - - - b - 
- - - - - - - - 
- - - - - - - - 
p p p n p p p p 
r - - q k b n r 
**********************************************
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Qd1:d2 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 

**********************************************
R - B Q K B N R 
- - - P P - P P 
N P - p - P - - 
P - P - - - b - 
- - - - - - - - 
- - - - - - - - 
p p p q p p p p 
r n - - k b n r 
**********************************************
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Qd1:d3 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 

**********************************************
R - B Q K B N R 
- - - P P - P P 
N P - p - P - - 
P - P - - - b - 
- - - - - - - - 
- - - q - - - - 
p p p - p p p p 
r n - - k b n r 
**********************************************
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Qd1:c1 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 

**********************************************
R - B Q K B N R 
- - - P P - P P 
N P - p - P - - 
P - P - - - b - 
- - - - - - - - 
- - - - - - - - 
p p p - p p p p 
r n q - k b n r 
**********************************************
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Ke1:d2 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 

**********************************************
R - B Q K B N R 
- - - P P - P P 
N P - p - P - - 
P - P - - - b - 
- - - - - - - - 
- - - - - - - - 
p p p k p p p p 
r n - q - b n r 
**********************************************
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Ng1:f3 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 

**********************************************
R - B Q K B N R 
- - - P P - P P 
N P - p - P - - 
P - P - - - b - 
- - - - - - - - 
- - - - - n - - 
p p p - p p p p 
r n - q k b - r 
**********************************************
1. Pd2:d4 Pa7:a5 2. Bc1:g5 Pb7:b6 3. Ng1:h3 Pc7:c5 4. Pd4:d5 Nb8:a6 5. Pd5:d6 Pf7:f6 

**********************************************
R - B Q K B N R 
- - - P P - P P 
N P - p - P - - 
P - P - - - b - 
- - - - - - - - 
- - - - - - - n 
p p p - p p p p 
r n - q k b - r 
**********************************************
Solutions founds: 25
\end{verbatim}
%\caption{Verbose output from example game.  Generating information sets for black after five turns by each player.
%From this, black can infer that there is definitely a white bishop at g5 and a white pawn at d6.}
%\label{verboseoutput}
%\end{figure}

\bibliographystyle{acm}
\bibliography{paper}

\end{document}
